<!DOCTYPE html>
<html>

<head>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Readex+Pro&display=swap" rel="stylesheet">
</head>

<body style="font-family: 'Readex Pro', sans-serif; background-color: lemonchiffon;">

	<!-- Imagem -->
	<h1>Imagem trabalhada:</h1>
	<canvas id="imagemOriginal" width="900" height="600"></canvas>

	<!-- Exerc√≠cio 1 -->

	<h1> Exerc√≠cio 1: Plotando gr√°fico RGB </h1>
	Fizemos uma fun√ß√£o que passa por cada pixel, adiciona a sua cor de vermelho, verde e azul a 
	um respectivo dicion√°rio de frequ√™ncias de cada cor e, ao final, usa esses dicion√°rios para 
	plotar os gr√°ficos usando a fun√ß√£o "lineTo()" do canvas.

<figure>
	<canvas id="graphRGB" width="256" height="400" style="border: 2px solid;"></canvas>
<figcaption>
		Gr√°fico RGB.
	</figcaption>
</figure>

<script>
	var canvasOriginal = document.getElementById("imagemOriginal");
	var ctxOriginal = canvasOriginal.getContext("2d");
	
	var canvasOut = document.getElementById("graphRGB");
	var canvasRGB = canvasOut.getContext("2d");
	
	var imgOriginal = new Image();
	var imgDataOut = new Image();
	var imgUrl = "https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/%D0%A8%D0%BF%D0%B8%D1%86%D1%96_3.jpg/1024px-%D0%A8%D0%BF%D0%B8%D1%86%D1%96_3.jpg";
   
	imgOriginal.crossOrigin = '';
	imgDataOut.crossOrigin = '';
    imgOriginal.src = imgUrl;
	imgOriginal.onload = function(){
		ctxOriginal.drawImage(imgOriginal, 0, 0);

		imgDataOut = ctxOriginal.getImageData(0, 0, 900, 600);
		dict_r = {};
		dict_g = {};
		dict_b = {};
		

		// passa por cada pixel e conta ele no respectivo dicion√°rio de frequ√™ncias
		for (let i = 0; i < imgDataOut.data.length; i += 4) {

			// r
			if ( isNaN(dict_r[imgDataOut.data[i]]) ) 
			{ dict_r[imgDataOut.data[i]] = 0};
			
			dict_r[imgDataOut.data[i]] += 1;

			// g
			if ( isNaN(dict_g[imgDataOut.data[i+1]]) ) 
			{ dict_g[imgDataOut.data[i+1]] = 0};

			dict_g[imgDataOut.data[i+1]] += 1;

			// b
			if ( isNaN(dict_b[imgDataOut.data[i+2]]) ) 
			{ dict_b[imgDataOut.data[i+2]] = 0};

			dict_b[imgDataOut.data[i+2]] += 1;

		}

		
		// plota o gr√°fico RGB
		let peso_h = 50; // regula a altura das barras
		let bottom = 400; //altura da imagem do plot
		for (let i = 0; i < 255; i += 1) {
			if ( !isNaN(dict_r[i]) ) {
				canvasRGB.beginPath(); 
				canvasRGB.moveTo(i, bottom);  
				canvasRGB.lineTo(i, bottom - (dict_r[i]/peso_h));
				canvasRGB.strokeStyle = '#ff0000aa';
				canvasRGB.stroke();  
			}};

		for (let i = 0; i < 255; i += 1) {
			if ( !isNaN(dict_g[i]) ) {
				canvasRGB.beginPath(); 
				canvasRGB.moveTo(i, bottom);  
				canvasRGB.lineTo(i, bottom - (dict_g[i]/peso_h));
				canvasRGB.strokeStyle = '#00ff00aa';
				canvasRGB.stroke();  
			}};

		for (let i = 0; i < 255; i += 1) {
			if ( !isNaN(dict_b[i]) ) {
				canvasRGB.beginPath(); 
				canvasRGB.moveTo(i, bottom);  
				canvasRGB.lineTo(i, bottom - (dict_b[i]/peso_h));
				canvasRGB.strokeStyle = '#0000ffaa';
				canvasRGB.stroke();  
			}};
};	    
</script>
	

	<!-- Exerc√≠cio 2 -->
	<h1> Exerc√≠cio 2: Plotando gr√°fico da Lumin√¢ncia </h1>
	O processo aqui foi bem semelhante ao anterior, com a excess√£o de que agora utilizamos, antes do processo 
	de plotagem do gr√°fico, uma fun√ß√£o retirada da <a href="https://css-tricks.com/converting-color-spaces-in-javascript/">internet</a> 
	que converte a imagem do modo RGB para o modo HSL, e ent√£o plotamos apenas a lumin√¢ncia.

<figure>
	<canvas id="graphluminancia" width="100" height="400" style="border: 2px solid; background-color: black;"></canvas>
<figcaption>
		Gr√°fico de lumin√¢ncia.
	</figcaption>
</figure>

<script>

	// fun√ß√£o copiada inteira e descaradamente do site fornecido
	function RGBToL(r,g,b) {
	// Make r, g, and b fractions of 1
	r /= 255;
	g /= 255;
	b /= 255;

	// Find greatest and smallest channel values
	let cmin = Math.min(r,g,b),
		cmax = Math.max(r,g,b),
		delta = cmax - cmin,
		h = 0,
		s = 0,
		l = 0;

	// Calculate hue
	// No difference
	if (delta == 0)
		h = 0;
	// Red is max
	else if (cmax == r)
		h = ((g - b) / delta) % 6;
	// Green is max
	else if (cmax == g)
		h = (b - r) / delta + 2;
	// Blue is max
	else
		h = (r - g) / delta + 4;

	h = Math.round(h * 60);
		
	// Make negative hues positive behind 360¬∞
	if (h < 0)
		h += 360;
	
	// Calculate lightness
		l = (cmax + cmin) / 2;

	// Calculate saturation
	s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
	
	// Multiply l and s by 100
	s = +(s * 100).toFixed(1);
	l = +(l * 100).toFixed(1);

	return l;
	}


	
	var canvasOriginal = document.getElementById("imagemOriginal");
	var ctxOriginal = canvasOriginal.getContext("2d");
	
	var canvasOut = document.getElementById("graphluminancia");
	var canvaslum = canvasOut.getContext("2d");
	
	var imgOriginal = new Image();
	var imgDataOut = new Image();

	var imgUrl = "https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/%D0%A8%D0%BF%D0%B8%D1%86%D1%96_3.jpg/1024px-%D0%A8%D0%BF%D0%B8%D1%86%D1%96_3.jpg";
	
	imgOriginal.crossOrigin = '';
	imgDataOut.crossOrigin = '';
    imgOriginal.src = imgUrl;
	imgOriginal.onload = function(){
		ctxOriginal.drawImage(imgOriginal, 0, 0);
		
		imgDataOut = ctxOriginal.getImageData(0, 0, 900, 600);

		dict_l = {};
		

		// passa por cada pixel e conta ele no respectivo dicion√°rio de frequ√™ncia
		for (let i = 0; i < imgDataOut.data.length; i += 4) {

			l = Math.round(RGBToL(imgDataOut.data[i], imgDataOut.data[i+1], imgDataOut.data[i+2]));

			if ( isNaN(dict_l[l]) ) 
			{ dict_l[l] = 0};
			dict_l[l] += 1;

		}

		// plota o gr√°fico de lumin√¢ncia
		let peso_h = 70; // regula a altura das barras
		let bottom = 400; //altura da imagem do plot
		for (let i = 0; i < 255; i += 1) {
			if ( !isNaN(dict_l[i]) ) {
				canvaslum.beginPath(); 
				canvaslum.moveTo(i, bottom);  
				canvaslum.lineTo(i, bottom - (dict_l[i]/peso_h));
				canvaslum.strokeStyle = '#ffffffaa';
				canvaslum.stroke();
			}};
};	    
</script>


	<!-- Exerc√≠cio 3 -->

	<h1> Exerc√≠cio 3: Alterando o Contraste da Foto </h1>
	Aqui, o truque √© passar por cada pixel e aplicar a seguinte fun√ß√£o: <br><br>
	<i>Nova lumin√¢ncia = m√©dia da lumin√¢ncia total + (lumin√¢ncia atual - m√©dia da lumin√¢ncia total) * peso</i> <br><br>
	Al√©m disso, foi necess√°rio novamente fazer a convers√£o RGB -> HSL, para que ent√£o pud√©ssemos transformar a lumin√¢ncia e,
	em seguida, converter novamente para RGB  e plotar a imagem.

	<figure>
	<canvas id="imagemOutput" width="900" height="600"></canvas>
	<canvas id="graphluminancia2" width="100" height="400" style="border: 2px solid; background-color: black;"></canvas>
<figcaption>
		Imagem com contraste elevado e novo gr√°fico de lumin√¢ncia ao lado.
	</figcaption>
</figure>
	<div style="margin-left: 3em;">
	<h2> Alguns pesos interessantes para brincar com o contraste:</h2> <br>
	<button onclick="newpeso(1)"> 1 </button>: Contraste inalterado pois o peso √© 1 üòê; <br>
	<button onclick="newpeso(1.5)"> 1.5 </button>: Contraste bonitinho que deixa a imagem bem espalhada üòÄ; <br>
	<button onclick="newpeso(2.5)"> 2.5 </button>: Contraste exagerado que j√° n√£o fica t√£o belo üò∞; <br>
	<button onclick="newpeso(0)"> 0 </button>: Todos os pixels ficam com a lumin√¢ncia igual a m√©dia üìä; <br>
	<button onclick="newpeso(200)"> 200 </button>: Praticamente preto e branco üñ§; <br>
	<button onclick="newpeso(-200)"> -200 </button>: Praticamente preto e branco, por√©m invertido ü§ç; <br>
	<button onclick="newpeso(Infinity)"> Infinity </button>: Sinceramente n√£o sei explicar ü§Ø; <br>
	</div>

<script>

	// Interatividade do usu√°rio
	let peso = 1.5;
	let cap = true;

	function newpeso(param) {

		if (param == Infinity) {cap = false}
		else {cap = true};

		peso = param;
		imgOriginal.onload();

	}




	//Fun√ß√µes copiadas descaradamente do site fornecido
	function RGBToHSL(r,g,b) {
	// Make r, g, and b fractions of 1
	r /= 255;
	g /= 255;
	b /= 255;

	// Find greatest and smallest channel values
	let cmin = Math.min(r,g,b),
		cmax = Math.max(r,g,b),
		delta = cmax - cmin,
		h = 0,
		s = 0,
		l = 0;

	// Calculate hue
	// No difference
	if (delta == 0)
		h = 0;
	// Red is max
	else if (cmax == r)
		h = ((g - b) / delta) % 6;
	// Green is max
	else if (cmax == g)
		h = (b - r) / delta + 2;
	// Blue is max
	else
		h = (r - g) / delta + 4;

	h = Math.round(h * 60);
		
	// Make negative hues positive behind 360¬∞
	if (h < 0)
		h += 360;
	
	// Calculate lightness
		l = (cmax + cmin) / 2;

	// Calculate saturation
	s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
	
	// Multiply l and s by 100
	s = +(s * 100).toFixed(1);
	l = +(l * 100).toFixed(1);

	return [h, s, l];
	}

	function HSLToRGB(h,s,l) {
	// Must be fractions of 1
	s /= 100;
	l /= 100;

	let c = (1 - Math.abs(2 * l - 1)) * s,
		x = c * (1 - Math.abs((h / 60) % 2 - 1)),
		m = l - c/2,
		r = 0,
		g = 0,
		b = 0;

		if (0 <= h && h < 60) {
			r = c; g = x; b = 0;  
		} else if (60 <= h && h < 120) {
			r = x; g = c; b = 0;
		} else if (120 <= h && h < 180) {
			r = 0; g = c; b = x;
		} else if (180 <= h && h < 240) {
			r = 0; g = x; b = c;
		} else if (240 <= h && h < 300) {
			r = x; g = 0; b = c;
		} else if (300 <= h && h < 360) {
			r = c; g = 0; b = x;
		}
		r = Math.round((r + m) * 255);
		g = Math.round((g + m) * 255);
		b = Math.round((b + m) * 255);

		return [r, g, b];
	}

	var canvasOut = document.getElementById("imagemOutput");
	var ctxOutput = canvasOut.getContext("2d");
	var graphlum2 = document.getElementById("graphluminancia2");
	var canvaslum2 = graphlum2.getContext("2d");
	
	var imgOriginal = new Image();
	var imgDataOut = new Image();
	
	var imgUrl = "https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/%D0%A8%D0%BF%D0%B8%D1%86%D1%96_3.jpg/1024px-%D0%A8%D0%BF%D0%B8%D1%86%D1%96_3.jpg";

	imgOriginal.crossOrigin = '';
	imgDataOut.crossOrigin = '';
    imgOriginal.src = imgUrl;
	imgOriginal.onload = function(){
		ctxOriginal.drawImage(imgOriginal, 0, 0);
		ctxOutput.drawImage(imgOriginal, 0, 0);
		
		imgDataOut = ctxOriginal.getImageData(0, 0, 900, 600);
		dict_h = 0;
		dict_s = 0;
		dict_l = {};
		
		// Passa por cada pixel e calcula a m√©dia de lumin√¢ncia da imagem
		let media_l = 0;
		let pixels = 0;
		for (let i = 0; i < imgDataOut.data.length; i += 4) {

			let hsl = RGBToHSL(imgDataOut.data[i], imgDataOut.data[i+1], imgDataOut.data[i+2]);
			
			let l = hsl[2];
			pixels ++;
			media_l += l;
		}
		media_l /= pixels;


		/* Reescreve a imagem transformando tudo pra HSL,
		alterando a lumin√¢ncia de acordo com o peso previamente fornecido,
		depois reconvertendo o HSL para RGB  e ent√£o plotando a
		nova imagem */

		let nova_img = ctxOriginal.getImageData(0, 0, 900, 600);
		for (let i = 0; i < imgDataOut.data.length; i += 4) {

			let hsl = RGBToHSL(imgDataOut.data[i], imgDataOut.data[i+1], imgDataOut.data[i+2]);

			h = hsl[0];
			s = hsl[1];

			// redefine as lumin√¢ncias
			l = media_l + (hsl[2] - media_l)*peso;

			if (cap){ //limita entre 0 e 100 se o peso n√£o for Infinity
			if (l < 0) {l = 0};
			if (l > 100) {l = 100};
			};

			let rgb = HSLToRGB(h, s, l);

			nova_img.data[i] = rgb[0];
			nova_img.data[i+1] = rgb[1];
			nova_img.data[i+2] = rgb[2];

		}
		
		ctxOutput.putImageData(nova_img, 0, 0);	

		// Faz novo gr√°fico de lumin√¢ncia
		dict_l = {};
		

		// passa por cada pixel e conta ele no respectivo dicion√°rio de frequ√™ncia
		for (let i = 0; i < nova_img.data.length; i += 4) {

			l = Math.round(RGBToL(nova_img.data[i], nova_img.data[i+1], nova_img.data[i+2]));

			if ( isNaN(dict_l[l]) ) 
			{ dict_l[l] = 0};
			dict_l[l] += 1;

		}

		// plota o gr√°fico de lumin√¢ncia
		let peso_h = 70; // regula a altura das barras
		let bottom = 400; //altura da imagem do plot
		canvaslum2.clearRect(0, 0, 100, 400); // apaga tudo que tinha antes
		for (let i = 0; i < 100; i += 1) {
			if ( !isNaN(dict_l[i]) ) {
				canvaslum2.beginPath(); 
				canvaslum2.moveTo(i, bottom);  
				canvaslum2.lineTo(i, bottom - (dict_l[i]/peso_h));
				canvaslum2.strokeStyle = '#ffffffaa';
				canvaslum2.stroke();
			}};
};	    
</script>
</body>
</html>